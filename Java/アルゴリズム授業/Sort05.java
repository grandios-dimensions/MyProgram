/** * 「アルゴリズムとデータ構造」 * Hirohito Shibata (hshibata@edu.teu.ac.jp) * * 「Sort05」 * 以下のソートを実装し、各アルゴリズムの実行速度を比較可能にしたもの。 */public class Sort05 extends SuperSort {    // 実行の種類    public static enum RunType {        Test,       // テスト実行        Time,       // 時間計測        Process,    // 途中経過報告        Detail,     // 詳細報告    }    // ソート方法の種類    public static enum SortType {        Select,     // 選択ソート        Bubble,     // バブルソート        Insert,     // 挿入ソート	Heap,	    // ヒープソート        Quick,      // クイックソート	Quick20,    // クリックソート + 挿入ソート (20で切り替え)        Merge,      // マージソート//      Bucket,     // バケットソート	Library,    // ライブラリの sort 関数    }    // 入力サイズ (探索対象のデータ数)    public static int n;    // 最初に呼ばれる関数    public static void main(String[] args) {        // [parameter] 実行の種類 (Test, Time, Process, Detail)        RunType runtype = RunType.Process;        // [parameter] ソート方法の種類 (Select, Bubble, Insert, Heap, Quick, Quick20, Merge, Library)        SortType sorttype = SortType.Quick;        // [parameter] データ数 (10000, 30000, 50000)        n = 10;        // 大きな配列のソートで途中結果を報告するのは時間がかかるからエラーにしてしまう       if (runtype != RunType.Time) {           if (n > 20) {               System.out.println("Too big !!!");               return;           }        }	// 配列の初期化	int[] D = initializeArray(n);	// シャッフル//	int[] D = { 4, 1, 5, 2, 6, 3 };	// 明示的に指定	// ソートの途中経過を表示するか否か	boolean process = false;        if (runtype == RunType.Process)            process = true;        // ソートの詳細経過を表示するか否か	boolean detail = false;        if (runtype == RunType.Detail)            detail = true;        // ストップウォッチの生成        StopWatch watch = new StopWatch();        // ソートの前処理        if (runtype == RunType.Time) {            watch.start();  // ストップウォッチの開始        } else {            // ソート前の配列を書き出す            System.out.println(get_string(D));        }	// ソート	switch (sorttype) {	case Select:	    SelectSort.process = process;	    SelectSort.detail = detail;	    SelectSort.sort(D);	    break;	case Insert:	    InsertSort.process = process;	    InsertSort.detail = detail;	    InsertSort.sort(D);	    break;	case Heap:	    HeapSort.process = process;	    HeapSort.detail = detail;	    HeapSort.sort(D);	    break;	case Quick:	    QuickSort.process = process;	    QuickSort.detail = detail;	    QuickSort.sort(D);	    break;	case Quick20:	    QuickSort.process = process;	    QuickSort.detail = detail;	    QuickSort.sortSwitch(D, 20);	    break;	case Merge:	    MergeSort.process = process;	    MergeSort.detail = detail;	    MergeSort.sort(D);	    break;	case Bubble:	    BubbleSort.process = process;	    BubbleSort.detail = detail;	    BubbleSort.sort(D);	    break;	case Library:	    java.util.Arrays.sort(D);	    break;	}	        // ソートの後処理        if (runtype == RunType.Time) {            // ストップウォッチの終了と時間表示            watch.stop();	// ストップウォッチの終了            watch.printTime();	// ストップウォッチの経過時間を表示        } else {            // ソート後の配列を書き出す            System.out.print("--> ");            System.out.println(get_string(D));        }    }    // 配列 a をマージソートする    private static int[] initializeArray(int m) {	// 配列の初期化        int[] a = new int[m];	// シャッフルするための基数を設定 (7 or 9)	int basenum = 7;	if (m % 7 == 0)	    basenum = 9;	// 配列の値を設定	for (int i = 0; i < m; i++)	    a[i] = (basenum * i) % m;	return a;    }}