/** * 「アルゴリズムとデータ構造」 * Hirohito Shibata (hshibata@edu.teu.ac.jp) * * 「クイックソート」 * 使い方:  *   - QuickSort.sort(D)		配列 D をソート *   - QuickSort.sort(D, left, right)	配列 D の left...right の範囲をソート *   - QuickSort.sortSwitch(D)		配列 D をソート (ただし、途中で挿入ソートに切り替え) */public class QuickSort extends SuperSort {    // 配列 a をクイックソートする    public static void sort(int[] a) {	quick_sort(a, 0, a.length - 1, -1);    }    // 配列 a の left から right まで (a[left]...a[right]) をクイックソートする    public static void sort(int[] a, int left, int right) {	quick_sort(a, left, right, -1);    }    // 配列 a をクイックソート&挿入ソートする    public static void sortSwitch(int[] a, int thresh) {	quick_sort(a, 0, a.length - 1, thresh);    }    // 配列 a の left から right まで (a[left]...a[right]) をクイックソートする    // thresh はクイックソートから挿入ソートへ切り替える敷居値。    private static void quick_sort(int[] a, int left, int right, int thresh) {	if (left >= right)	    return;	if (thresh > 0 && right - left < thresh) {	    // 挿入ソートに切り替え	    if (detail)		System.out.printf("  insert_sort(a, %d, %d) \r\n", left, right);	    // 挿入ソート	    InsertSort.detail = detail;	    InsertSort.process = process;	    InsertSort.sort(a, left, right);	} else {	    // 通常のクイックソート	    if (detail) {		System.out.printf("  quick_sort(a, %d, %d) \r\n", left, right);	    }	    // 配列 D の left から right まで (a[left]...a[right]) を	    // 基準値で分割し、基準値の格納されたインデックスを返す。	    int x = partition(a, left, right);	    if (process || detail)	// 途中経過を表示		System.out.println(get_string_focus(a, left, x, right));	  	    // 基準値の左側の配列に対して再帰呼び出し	    quick_sort(a, left, x - 1, thresh);	    // 基準値の右側の配列に対して再帰呼び出し	    quick_sort(a, x + 1, right, thresh);	}    }    // 配列 a の left から right まで (a[left]...a[right]) を    // 基準値で分割し、基準値の格納されたインデックスを返す。    private static int partition(int[] a, int left, int right) {	// left, right が隣り合っている場合 (partition での分割対象が2つしかない場合) は特別な振る舞いにしておく。	// そうしておかないと正しく動作しない (教科書どおりの実装では正しく動作しない)。	// 理由は a = {2, 1} (left=0, right=1) のような配列を考えると、	// k=i=j=0となって、ソート結果が {2, 1} となり、正しくソートされない。	if (left == right - 1) {	    // left, right が隣り合っている場合は、比較して入れ替え。	    if (a[left] > a[right]) {		swap(a, left, right);	    }	    return left;	}	// 基準値のインデックスを選択	int k = (left + right) / 2;	// 基準値を右端に移動	swap(a, k, right);	int i = left;	int j = right - 1;	while (i < j) {	    // 基準値以上の位置 i、基準値より小さい位置 j を探す	    while (a[i] < a[right]) {		i = i + 1;	    }	    while (j >= i && a[j] >= a[right]) {		j = j - 1;	    }	    // i < j なら、a[i], a[j] を交換	    if (i < j) {		swap(a, i, j);	    }	}	swap(a, i, right);	// 基準値を分割の真ん中に入れる	return i;		// 基準値の位置を返す    }}