/* * 「アルゴリズムとデータ構造」 * ソート: 選択ソート, 挿入ソート, ヒープソート * Hirohito Shibata (hshibata@stf.teu.ac.jp) */public class Sort02 {    // 実行の種類    public static enum RunType {        Test,   // テスト実行        Time,   // 時間計測    }    // ソート方法の種類    public static enum SortType {        Select,     // 選択ソート        Insert,     // 挿入ソート        Heap,       // ヒープソート    }    // 入力サイズ (探索対象のデータ数)    public static int n;    // ソート対象のデータ    public static int[] D;    // 最初に呼ばれる main 関数    public static void main(String[] args) {        // [parameter] 実行の種類 (Test, Time)        RunType runtype = RunType.Test;        // [parameter] ソート方法の種類 (Select, Insert)        SortType sorttype = SortType.Heap;        // [parameter] データ数 (10000, 30000, 50000)        n = 50000;        if (runtype == RunType.Test)            n = 10;                // 配列の初期化        D = new int[n];        // シャッフルした配列        for (int i = 0; i < n; i++) {            D[i] = (3 * i) % n;        }        if (runtype == RunType.Test) {  // テスト実行            System.out.println(get_string(D));            // ソート            if (sorttype == SortType.Select) {                select_sort(D);            } else if (sorttype == SortType.Insert) {                insert_sort(D);            } else {                heap_sort(D);            }            System.out.println("--> " + get_string(D));        } else { // 時間計測            // ストップウォッチの生成と開始            StopWatch watch = new StopWatch();	// ストップウォッチの生成            watch.start();			// ストップウォッチの開始            // ソート            if (sorttype == SortType.Select) {                select_sort(D);            } else if (sorttype == SortType.Insert) {                insert_sort(D);            } else {                heap_sort(D);            }            // ストップウォッチの終了と時間表示            watch.stop();	// ストップウォッチの終了            watch.printTime();	// ストップウォッチの経過時間を表示        }    }    // ヒープでのデータ数    public static int size;    // 配列 a を「ヒープソート」でソートする。    public static void heap_sort(int[] a) {        int[] T = new int[a.length + 1];        size = 0;	// ヒープのデータサイズ        // 全ての値をヒープに格納        for (int i = 0; i < a.length; i++) {            push_heap(T, a[i]);        }        // ヒープから1つずつ取り出して、大きい順に後ろから並べる        for (int i = a.length - 1; i >= 0; i--) {            a[i] = delete_maximum(T);        }    }    // ヒープ T にデータ x を格納    public static void push_heap(int[] T, int x) {        // !!#        // ヒープ T にデータ x を格納するアルゴリズムを記述せよ。    }    // ヒープ T から最大の値を取得    public static int delete_maximum(int[] T) {        // !!#        // ヒープ T から最大の値を取得して返すアルゴリズムを記述せよ。    }    // 配列 a を「選択ソート」でソートする。    public static void select_sort(int[] a) {        // !!#        //  配列 a を「選択ソート」でソートするアルゴリズムを記述せよ。    }    // 配列 a を「挿入ソート」でソートする。    public static void insert_sort(int[] a) {        // !!#        //  配列 a を「挿入ソート」でソートするアルゴリズムを記述せよ。    }    // 配列 a の i 番目の要素と j 番目の要素を入れ替える。    public static void swap(int[] a, int i, int j) {        if (i != j) {            int tmp = a[i];            a[i] = a[j];            a[j] = tmp;        }    }    // 配列から文字列を生成して返す。    public static String get_string(int[] a) {        String str = "{ ";        for (int i = 0; i < a.length; i++) {            if (i > 0) {                str += ", ";            }            str += a[i];        }        str += " }";        return str;    }}