// 「アルゴリズムとデータ構造」// ソート: 選択ソート, 挿入ソート, バブルソート, マージソート// Hirohito Shibatapublic class Sort03 {    // 実行の種類    public static enum RunType {        Test,       // テスト実行        Time,       // 時間計測        Process,    // 途中経過報告        Detail,     // 詳細報告    }    // ソート方法の種類    public static enum SortType {        Select,     // 選択ソート        Insert,     // 挿入ソート        Bubble,     // バブルソート        Merge,      // クイックソート    }    // 入力サイズ (探索対象のデータ数)    public static int n;    // ソートの途中経過を表示するか否か    public static boolean process = false;    // ソートの詳細経過を表示するか否か    public static boolean detail = false;    // 最初に呼ばれる関数    public static void main(String[] args) {        // [parameter] 実行の種類 (Test, Time, Process, Detail)        RunType runtype = RunType.Test;        // [parameter] ソート方法の種類 (Select, Insert, Bubble, Merge)        SortType sorttype = SortType.Merge;        // [parameter] データ数 (10000, 30000, 50000)        n = 30000;        if (runtype != RunType.Time)            n = 10;                // 配列の初期化        int[] D = new int[n];        // シャッフルした配列        for (int i = 0; i < n; i++) {            D[i] = (3 * i) % n;        }        if (runtype == RunType.Test || runtype == RunType.Process || runtype == RunType.Detail) {            // テスト実行 or プロセス実行            // プロセス実行の場合は変数 process を true に設定する            if (runtype == RunType.Process)                process = true;            else if(runtype == RunType.Detail)                detail = true;            System.out.println(get_string(D));            // ソート            if (sorttype == SortType.Select) {                select_sort(D);            } else if (sorttype == SortType.Insert) {                insert_sort(D);            } else if (sorttype == SortType.Bubble) {                 bubble_sort(D);            } else {                merge_sort(D);            }            System.out.print("--> ");            System.out.println(get_string(D));        } else {            // 時間計測            // ストップウォッチの生成と開始            StopWatch watch = new StopWatch();	// ストップウォッチの生成            watch.start();			// ストップウォッチの開始            // ソート            if (sorttype == SortType.Select) {                select_sort(D);            } else if (sorttype == SortType.Insert) {                insert_sort(D);            } else if (sorttype == SortType.Bubble) {                 bubble_sort(D);           } else {                merge_sort(D);            }            // ストップウォッチの終了と時間表示            watch.stop();	// ストップウォッチの終了            watch.printTime();	// ストップウォッチの経過時間を表示        }    }    // 配列 a を「選択ソート」でソートする。    public static void select_sort(int[] a) {        for (int i = 0; i < a.length-1; i++) {            // 最小の要素を探す            int min_index = i;	// 最小の要素のインデックス            for (int j = i + 1; j < a.length; j++) {                if (a[j] < a[min_index]) {                    min_index = j;                }            }            // i番目の要素を最小のものに入れ替え            swap(a, i, min_index);            if (process || detail) // 途中経過を表示                System.out.println(get_string(a, i));        }    }        // 配列 a を「挿入ソート」でソートする。    public static void insert_sort(int[] a) {        for (int i = 1; i < a.length; i++) {            int x = a[i];	// 挿入する要素            // 挿入位置を探す            int j = i;            while ((j > 0) && (a[j - 1] > x)) {                a[j] = a[j - 1];	// D[j-1]のほうが大きければ、値を右にずらす                j--;            }            // 挿入位置に値を設定            a[j] = x;            if (process || detail) // 途中経過を表示                System.out.println(get_string(a, j));        }    }    // 配列 a を「バブルソート」でソートする。    public static void bubble_sort(int[] a) {        // !!#    }        // マージの際に利用する配列    public static int[] M;        // 配列 a の left...mid (左のソート列) と mid+1...right (右のソート列) をマージする。    public static void merge_sort(int[] a) {	M = new int[a.length];	merge_sort(a, 0, a.length - 1);    }        // 配列 a の left から right まで (a[left]...a[right]) をマージソートする    // thresh は挿入ソートへ切り替える敷居値。    public static void merge_sort(int[] a, int left, int right) {        if (left < right) {            // 途中結果の表示            if (detail) {                System.out.println("  merge_sort(a, " + left + ", " + right + ")");            }            int mid = (left + right) / 2; // 中間位置            // 左半分のソート            if (left < mid)                merge_sort(a, left, mid);            // 右半分のソート            if (mid + 1 < right)                merge_sort(a, mid + 1, right);            // 2つの配列を統合            merge(a, left, mid, right);        }    }    // 配列 a の left...mid (左のソート列) と mid+1...right (右のソート列) をマージする。    private static void merge(int[] a, int left, int mid, int right) {	// 途中結果の表示	if (detail) {            System.out.println("  merge(a, " + left + ", " + mid + ", " + right + ")");	    System.out.println(get_string_center(a, left, mid, right));	}        // !!#    }        // 配列 a の i 番目の要素と j 番目の要素を入れ替える。    public static void swap(int[] a, int i, int j) {        if (i != j) {            int tmp = a[i];            a[i] = a[j];            a[j] = tmp;        }    }    // 配列から文字列を生成して返す。    public static String get_string(int[] a) {        return get_string(a, -1);    }    // 配列から文字列を生成して返す。    // focus で正の値を設定すると、その位置の要素を "<", ">" で囲って目立つようにする。    public static String get_string(int[] a, int focus) {        String str = "{ ";        for (int i = 0; i < a.length; i++) {            if (i > 0) {                str += ", ";            }            if (focus >= 0 && i == focus) {                str += "<" + a[i] + ">";            } else {                str += a[i];            }        }        str += " }";        return str;    }        // 配列から文字列を生成して返す。    // f1 の位置に "(", f2 の位置に "|", f3 の位置に ")" を挿入。    protected static String get_string_center(int[] a, int f1, int f2, int f3) {	String str = "{ ";	for (int i = 0; i < a.length; i++) {	    if (i > 0)		str += ", ";	    if (f1 >= 0 && i == f1)		str += "( ";	    if (f2 >= 0 && i == f2 + 1)		str += "| ";	    str += a[i];	    if (f3 >= 0 && i == f3)		str += " )";	}	str += " }";	return str;    }}