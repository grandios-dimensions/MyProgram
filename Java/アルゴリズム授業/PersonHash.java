// 「アルゴリズムとデータ構造」探索アルゴリズムの速度比較// Hirohito Shibata (hshibata@cs.teu.ac.jp)import java.io.*;public class PersonHash {    // 入力サイズ (探索対象のデータ数)    public static int n = 0;    // ハッシュ法での配列サイズ    public static int M = 15000;    // ハッシュ法でデータを格納する配列    public static String[] H;    // ハッシュ関数の種類    public static enum HashType {	AllOne,     // どんな場合でも1を返す	Length,     // 人名の文字数 * 100	SumCode,    // 文字コードを総和	HashCode,   // Javaの文字列ライブラリに用意されているハッシュ関数 hashCode()     }    public static int ini_collision = 0;    // 最初の衝突回数    public static int collision = 0;        // トータルでの衝突回数    // 最初に呼ばれる関数    public static void main(String[] args) {        // ハッシュ関数の種類        // !!# 各々の実行に合わせて、ハッシュの種類を変更せよ。        HashType type = HashType.HashCode;;	// ファイル名        // !!# ファイル persons.txt は src の下にあることが前提	String filename = ".\\src\\persons.txt";	// ハッシュの配列を初期化	H = new String[M];	// 配列の生成	for (int i = 0; i < M; i++)            H[i] = "";	// *** ハッシュへの値の格納 ***	System.out.println("Insert");	try {            FileReader fr = new FileReader(filename);            BufferedReader br = new BufferedReader(fr);            String str;            while ((str = br.readLine()) != null) {		hashInsert(type, str);		n++;            }        } catch (IOException e) {            e.printStackTrace();            System.out.println("ファイル入出力で不正な処理が発生しました．");            System.exit(1);	}	// 挿入結果の報告	System.out.printf("  person names = %d \r\n", n);	System.out.printf("  initial collision = %d \r\n", ini_collision);	System.out.printf("  total collision = %d \r\n", collision);	// *** ハッシュからの値の探索 ***	System.out.println("Search");	// ストップウォッチの生成と開始	StopWatch watch = new StopWatch();	// ストップウォッチの生成	watch.start();				// ストップウォッチの開始	try {            FileReader fr = new FileReader(filename);            BufferedReader br = new BufferedReader(fr);            String str;            while ((str = br.readLine()) != null) {                hashSearch(type, str);            }        } catch (IOException e) {            e.printStackTrace();            System.out.println("ファイル入出力で不正な処理が発生しました．");            System.exit(1);	}	// ストップウォッチの終了と時間表示	watch.stop();		// ストップウォッチの終了	watch.printTime();	// ストップウォッチの経過時間を表示    }    // ハッシュ関数    // 値 x のハッシュ値 (最初の格納場所) を返す。    // type はハッシュ関数の種類を示す。    public static int hash(HashType type, String x)    {	if (type == HashType.AllOne) {            return 1;	} else if (type == HashType.Length) {            return x.length() * 100 % M;        } else if (type == HashType.SumCode) {            int h = 0;            for (int i = 0; i < x.length(); i++) {                char c = x.charAt(i);                h = (h + (int) c) % M;            }            if (h < 0)                h = -h;            return h % M;        } else if (type == HashType.HashCode) {            int h = x.hashCode();            if (h < 0)                h = -h;            return h % M;        }        return 0;    }    // サイズ m の配列 H に対して、値 x を格納する。    // type はハッシュ関数の種類を示す。    public static void hashInsert(HashType type, String x)    {        boolean initflg = true;	// 最初の衝突か否かを判定するためのフラグ        int k = hash(type, x);	// 最初の位置        // 空の位置を探す        while (!H[k].equals("")) {            if (initflg) {                ini_collision++;                initflg = false;            }            k = (k + 1) % M;            collision++;        }        H[k] = x;	// 格納    }    // サイズ m の配列 H に対して、値 x が格納されているかを探す。    // あった場合はその位置、なかった場合は負を返す。    // type はハッシュ関数の種類を示す。    public static int hashSearch(HashType type, String x)    {        int k = hash(type, x);	// 最初の位置        // 一致する場所を見つけるか、空の位置に出会うかするまで繰り返す。        while (!H[k].equals("")) {            if (H[k] == x) {                return k;	// Found!            }            k = (k + 1) % M;        }        return -1;	// Not Found!    }}