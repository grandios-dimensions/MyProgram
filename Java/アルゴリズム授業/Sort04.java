// 「アルゴリズムとデータ構造」// ソート: 選択ソート, 挿入ソート, クイックソート// Hirohito Shibata (hshibata@cs.teu.ac.jp)public class Sort04 {    // 実行の種類    public static enum RunType {        Test,       // テスト実行        Time,       // 時間計測        Process,    // 途中経過報告        Detail,     // 詳細報告    }    // ソート方法の種類    public static enum SortType {        Select,     // 選択ソート        Insert,     // 挿入ソート        Quick,      // クイックソート    }    // 入力サイズ (探索対象のデータ数)    public static int n;    // ソートの途中経過を表示するか否か    public static boolean process = false;    // ソートの詳細経過を表示するか否か    public static boolean detail = false;    // 最初に呼ばれる関数    public static void main(String[] args) {        // [parameter] 実行の種類 (Test, Time, Process, Detail)        RunType runtype = RunType.Test;        // [parameter] ソート方法の種類 (Select, Insert, Quick)        SortType sorttype = SortType.Quick;        // [parameter] データ数 (10000, 30000, 50000)        n = 10000;        if (runtype != RunType.Time)            n = 10;                // 配列の初期化        int[] D = new int[n];        // シャッフルした配列        for (int i = 0; i < n; i++) {            D[i] = (3 * i) % n;        }        if (runtype == RunType.Test || runtype == RunType.Process || runtype == RunType.Detail) {            // テスト実行 or プロセス実行            // プロセス実行の場合は変数 process を true に設定する            if (runtype == RunType.Process)                process = true;            else if(runtype == RunType.Detail)                detail = true;            System.out.println(get_string(D));            // ソート            if (sorttype == SortType.Select) {                select_sort(D);            } else if (sorttype == SortType.Insert) {                insert_sort(D);            } else {                quick_sort(D, 0, D.length - 1);            }            System.out.print("--> ");            System.out.println(get_string(D));        } else {            // 時間計測            // ストップウォッチの生成と開始            StopWatch watch = new StopWatch();	// ストップウォッチの生成            watch.start();			// ストップウォッチの開始            // ソート            if (sorttype == SortType.Select) {                select_sort(D);            } else if (sorttype == SortType.Insert) {                insert_sort(D);            } else {                quick_sort(D, 0, D.length - 1);            }            // ストップウォッチの終了と時間表示            watch.stop();	// ストップウォッチの終了            watch.printTime();	// ストップウォッチの経過時間を表示        }    }    // 配列 a の left から right まで (a[left]...a[right]) をクイックソートする    public static void quick_sort(int[] a, int left, int right) {        if (left < right) {            if (detail)		System.out.printf("  quick_sort(a, %d, %d) \r\n", left, right);            // 配列 D の left から right まで (a[left]...a[right]) を            // 基準値で分割し、基準値の格納されたインデックスを返す。            int x = partition(a, left, right);            if (process || detail)	// 途中経過を表示                System.out.println(get_string(a, x));            // 基準値の左側の配列に対して再帰呼び出し            quick_sort(a, left, x - 1);            // 基準値の右側の配列に対して再帰呼び出し            quick_sort(a, x + 1, right);        }    }    // 配列 a の left から right まで (a[left]...a[right]) から基準値を選び、    // 基準値よりも小さいものが左、基準値よりも大きなものが右になるように分割する。    // 基準値の位置を返す。    public static int partition(int[] a, int left, int right) {        // !!#        // 関数を実装せよ。        // 関数の仕様については、上の関数の説明を参照せよ。    }    // 配列 a を「選択ソート」でソートする。    public static void select_sort(int[] a) {        for (int i = 0; i < a.length-1; i++) {            // 最小の要素を探す            int min_index = i;	// 最小の要素のインデックス            for (int j = i + 1; j < a.length; j++) {                if (a[j] < a[min_index]) {                    min_index = j;                }            }            // i番目の要素を最小のものに入れ替え            swap(a, i, min_index);            if (process || detail) // 途中経過を表示                System.out.println(get_string(a, i));        }    }    // 配列 a を「挿入ソート」でソートする。    public static void insert_sort(int[] a) {        for (int i = 1; i < a.length; i++) {            int x = a[i];	// 挿入する要素            // 挿入位置を探す            int j = i;            while ((j > 0) && (a[j - 1] > x)) {                a[j] = a[j - 1];	// D[j-1]のほうが大きければ、値を右にずらす                j--;            }            // 挿入位置に値を設定            a[j] = x;            if (process || detail) // 途中経過を表示                System.out.println(get_string(a, j));        }    }    // 配列 a の i 番目の要素と j 番目の要素を入れ替える。    public static void swap(int[] a, int i, int j) {        if (i != j) {            int tmp = a[i];            a[i] = a[j];            a[j] = tmp;        }    }    // 配列から文字列を生成して返す。    public static String get_string(int[] a) {        return get_string(a, -1);    }    // 配列から文字列を生成して返す。    // focus で正の値を設定すると、その位置の要素を "<", ">" で囲って目立つようにする。    public static String get_string(int[] a, int focus) {        String str = "{ ";        for (int i = 0; i < a.length; i++) {            if (i > 0) {                str += ", ";            }            if (focus >= 0 && i == focus) {                str += "<" + a[i] + ">";            } else {                str += a[i];            }        }        str += " }";        return str;    }}