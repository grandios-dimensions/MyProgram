/** * 「アルゴリズムとデータ構造」 * Hirohito Shibata (hshibata@edu.teu.ac.jp) * * 「マージソート」 * 使い方:  *   - MergeSort.sort(D)	配列 D をソート */public class MergeSort extends SuperSort {    // マージの際に利用する配列    private static int[] M;    // 配列 a をマージソートする    public static void sort(int[] a) {	M = new int[a.length];	merge_sort(a, 0, a.length - 1);    }    // 配列 a をマージソートする    public static void sortSwitch(int[] a, int thresh) {	M = new int[a.length];	merge_sort(a, 0, a.length - 1);    }    // 配列 a の left から right まで (a[left]...a[right]) をマージソートする    // thresh は挿入ソートへ切り替える敷居値。    private static void merge_sort(int[] a, int left, int right) {        if (left < right) {            // 途中結果の表示            if (detail) {                System.out.println("  merge_sort(a, " + left + ", " + right + ")");            }            int mid = (left + right) / 2; // 中間位置            // 左半分のソート            if (left < mid)                merge_sort(a, left, mid);            // 右半分のソート            if (mid + 1 < right)                merge_sort(a, mid + 1, right);            // 2つの配列を統合            merge(a, left, mid, right);        }    }    // 配列 a の left...mid (左のソート列) と mid+1...right (右のソート列) をマージする。    private static void merge(int[] a, int left, int mid, int right) {	// 途中結果の表示	if (detail) {            System.out.println("  merge(a, " + left + ", " + mid + ", " + right + ")");	    System.out.println(get_string_center(a, left, mid, right));	}	int x = left;	int y = mid + 1;	for (int i = left; i <= right; i++) {	    if (x == mid + 1) { 			// 左のソート列が空の場合		M[i] = a[y];		y++;	    } else if (y == right + 1) {	// 右のソート列が空の場合		M[i] = a[x];		x++;	    } else if (a[x] <= a[y]) {	// 左のソート列の先頭が小さい場合		M[i] = a[x];		x++;	    } else {					// 右のソート列の先頭が小さい場合		M[i] = a[y];		y++;	    }	}	// 配列 M から配列 a にコピー	for (int i = left; i <= right; i++) {	    a[i] = M[i];	}	// 途中結果の表示	if (process || detail) {	    System.out.println(get_string_center(a, left, -1, right));	}    }}