// 「アルゴリズムとデータ構造」// ソート: ヒープのデータ構造// Hirohito Shibata (hshibata@edu.teu.ac.jp)public class Heap {    // ヒープでのデータ数    private static int size;    // 2分木のための配列    private int[] T;    // ヒープのコンストラクタ。要素数を指定。    public void initialize(int n) {	size = 0;	T = new int[n + 1];    }    // ヒープにデータ x を格納    public void push_heap(int x) {	size++;		// データの格納場所	T[size] = x;	// データを最後に追加	int k = size;	while ((k > 1) && (T[k] > T[k / 2])) {	    // 親のほうが小さければ値を交換	    swap(T, k, k / 2);	    // 次の親	    k = k / 2;	}    }    // ヒープから最大の値を削除して取得    public int delete_maximum() {	int max = T[1];	// 最大値を保持	// 右端のノードをルートに移動	T[1] = T[size];	T[size] = -1;	size--;	// ルートから始まって、子供がある限り繰り返す	int k = 1;	while (2 * k <= size) {	// 子をもつかどうか判定	    if (2 * k == size) {// 子供が1つの場合		// 親子の値を比較		if (T[k] < T[2 * k]) {		    swap(T, k, 2 * k);	// 親が小さいなら交換		    k = 2 * k;		} else {		    break;	// 終了		}	    } else {	// 子供が2つの場合		// 大きい値の子のインデックスをbigに格納s		int big;		if (T[2 * k] > T[2 * k + 1]) {		    big = 2 * k;		} else {		    big = 2 * k + 1;		}		// 親子の値を比較		if (T[k] < T[big]) {		    swap(T, k, big);	// 親が小さいなら交換		    k = big;		} else {		    break; // 終了		}	    }	}	return max;	// 保持しておいた最大値を返す    }    // 現在のヒープの要素数を取得    public int get_size() {	return size;    }    // 配列 a の i 番目の要素と j 番目の要素を入れ替える。    private void swap(int[] a, int i, int j) {	if (i != j) {	    int tmp = a[i];	    a[i] = a[j];	    a[j] = tmp;	}    }}